package labradar

import (
	"bufio"
	"encoding/json"
	"fmt"
	"github.com/carolynvs/aferox"
	"github.com/sirupsen/logrus"
	"github.com/spf13/afero"
	"opgenorth.net/mylittlerangebook/pkg/config"
	"opgenorth.net/mylittlerangebook/pkg/context"
	"os"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"
)

type Series struct {
	Number     int                 `json:"number"`
	Labradar   *Device             `json:"labradar"`
	Velocities *VelocityData       `json:"velocities"`
	Firearm    *Firearm            `json:"firearm"`
	LoadData   *LoadData           `json:"loadData"`
	Notes      string              `json:"notes"`
	RawData    map[int]*LineOfData `json:"data"`
}

type SeriesError struct {
	Msg    string
	Number int
}

func (s SeriesError) Error() string {
	return fmt.Sprintf("There was a problem trying to process series %d: %s.", s.Number, s.Msg)
}

func NewSeries() *Series {

	now := time.Now()

	u := &UnitsOfMeasure{
		Velocity: "fps",
		Distance: "m",
		Weight:   "gr (grains)",
	}
	d := &Device{
		"",
		now.Format("YYYY-MM-DD"),
		now.Format("15:04"),
		context.DefaultTimeZone,
		fmt.Sprintf("SR%04d", 0),
		u,
	}

	vd := &VelocityData{
		Average:           0,
		Max:               0,
		Min:               0,
		ExtremeSpread:     0,
		StandardDeviation: 0,
		Values:            nil,
	}
	f := &Firearm{
		Name:      "",
		Cartridge: "",
	}
	pr := &Projectile{
		Name:   "",
		Weight: 0,
		BC: &BallisticCoefficient{
			DragModel: "",
			Value:     0,
		},
	}
	po := &PowderCharge{
		Name:   "",
		Amount: 0,
	}
	ld := &LoadData{
		Cartridge:  "",
		Projectile: pr,
		Powder:     po,
	}
	ls := &Series{
		Number:     0,
		Labradar:   d,
		Velocities: vd,
		Firearm:    f,
		LoadData:   ld,
		Notes:      "",
		RawData:    make(map[int]*LineOfData),
	}

	return ls
}

func (s Series) TotalNumberOfShots() int {
	return len(s.Velocities.Values)
}

func (s Series) ToJsonBytes() []byte {
	jsonBytes, err := json.MarshalIndent(SortLinesOfData(s.RawData), "", "  ")
	if err != nil {
		return nil
	}

	return jsonBytes
}

func (s Series) ToJson() (string, error) {
	jsonBytes, err := json.MarshalIndent(SortLinesOfData(s.RawData), "", "  ")
	if err != nil {
		return "", err
	}

	return fmt.Sprintf("%x", jsonBytes), nil
}

func (s *Series) SetProjectile(projectileDescription string) {
	if len(projectileDescription) > 0 {
		s.LoadData.Projectile = parseProjectileString(projectileDescription)
	}
}

func (s *Series) SetPowder(powderDescription string) {
	if len(powderDescription) > 0 {
		s.LoadData.Powder = parsePowderString(powderDescription)
	}
}

func parsePowderString(powder string) *PowderCharge {
	parts := RemoveEmptyStrings(strings.Split(powder, " "))
	if len(parts) < 1 {
		return &PowderCharge{Name: "Unknown", Amount: 0.0}
	}

	p := &PowderCharge{
		Name:   parseNameOfProjectileFromString(strings.Join(parts[1:], " ")),
		Amount: parseAmountFromPowderString(parts[0]),
	}
	return p
}

func parseProjectileString(projectile string) *Projectile {
	parts := RemoveEmptyStrings(strings.Split(projectile, " "))

	if len(parts) < 1 {
		return &Projectile{Name: "Unknown", Weight: 0, BC: nil}
	}

	p := &Projectile{
		Name:   parseNameOfProjectileFromString(strings.Join(parts[1:], " ")),
		Weight: parseWeightFromProjectileString(parts[0]),
		BC:     nil, // [TO20220106] We don't worry about BC right now.
	}

	return p
}

func parseNameOfProjectileFromString(name string) string {

	replacer := strings.NewReplacer(
		"grains", "",
		"grain", "",
		"gr.", "",
		"gr", "",
	)
	return strings.TrimSpace(replacer.Replace(name))
}

func parseAmountFromPowderString(amount string) float32 {

	replacer := strings.NewReplacer(
		"grains", "",
		"grain", "",
		"gr.", "",
		"gr", "",
	)

	str := strings.TrimSpace(replacer.Replace(amount))

	w, err := strconv.ParseFloat(str, 32)
	if err != nil {
		return 0.0
	}

	return float32(w)
}

func parseWeightFromProjectileString(weight string) int {

	replacer := strings.NewReplacer(
		"grains", "",
		"grain", "",
		"gr.", "",
		"gr", "",
	)

	str := strings.TrimSpace(replacer.Replace(weight))

	w, err := strconv.ParseFloat(str, 32)
	if err != nil {
		return 0
	}

	return int(w)
}

func initDevice(seriesNumber int, timezone *time.Location) *Device {
	now := time.Now().In(timezone)

	u := &UnitsOfMeasure{
		Velocity: "fps",
		Distance: "m",
		Weight:   "gr (grains)",
	}
	return &Device{
		"",
		now.Format("YYYY-MM-DD"),
		now.Format("15:04"),
		timezone.String(),
		fmt.Sprintf("SR%04d", seriesNumber),
		u,
	}
}

// LbrFiles is a collection of all the serialized CSV files that are generated by LabRadar.
type LbrFiles struct {
	InputDir string
	Files    []*CsvFile
}

func (df LbrFiles) String() string {
	return df.InputDir
}

// LoadLabradarDataFiles will attempt load and de-serialize the CSV files for a given Labradar instance.
func LoadLabradarDataFiles(c *config.Config, inputDir string) *LbrFiles {
	dir, err := os.Stat(inputDir)

	f := &LbrFiles{
		inputDir,
		make([]*CsvFile, 0),
	}
	if err != nil {
		return f
	}

	if !dir.IsDir() {
		return f
	}

	f.Files = getLabradarCsvFiles(c, inputDir)
	return f
}

// CsvFile is a serialized Labradar CSV file.
type CsvFile struct {
	*Series
	InputFile string
	Error     error
}

func (f CsvFile) String() string {
	return f.InputFile
}

// LoadCsv will read a single Labradar CSV file (identified by it's seriesNumber).
func LoadCsv(c *config.Config, inputDir string, seriesNumber int) *CsvFile {
	f := loadCsvInternal(c.FileSystem, FilenameForSeries(inputDir, seriesNumber))
	return f
}

// getLabradarCsvFiles will read all the Labradar CSV files from the given directory.
func getLabradarCsvFiles(c *config.Config, inputDir string) []*CsvFile {
	var files []*CsvFile
	for _, filename := range getCsvFilenamesInDirectory(inputDir) {
		logrus.Debugf("Trying to read the file %s.", filename)
		f := loadCsvInternal(c.FileSystem, filename)
		if f.Error == nil {
			files = append(files, f)
		}
	}
	return files
}

// loadCsvInternal Will deserialize a Labaradar file into a CsvFile.
func loadCsvInternal(fs aferox.Aferox, filename string) *CsvFile {
	f, err := fs.Open(filename)
	if err != nil {
		return &CsvFile{
			nil,
			filename,
			err,
		}
	}
	defer closeFile(f)

	sb := NewSeriesBuilder()
	s := bufio.NewScanner(f)
	var lineNumber = 0
	for s.Scan() {
		ld := NewLineOfData(lineNumber, s.Text())
		sb.ParseLine(ld)
		lineNumber++
	}

	return &CsvFile{
		Series:    sb.Series,
		InputFile: filename,
		Error:     nil,
	}
}

// FilenameForSeries Given the Number of a series and the root directory of the Labradar files, infer the filename of the Labradar
// CSV file that holds the results of the series.
func FilenameForSeries(labradarRootDirectory string, seriesNumber int) string {
	stub := fmt.Sprintf("%04d", seriesNumber)
	//goland:noinspection SpellCheckingInspection
	subdir := fmt.Sprintf("SR%s", stub)
	filename := fmt.Sprintf("SR%s Report.csv", stub)
	p := path.Join(labradarRootDirectory, subdir, filename)
	return p
}
func outputFileNameFor(seriesNumber int, outputDir string) string {
	stub := fmt.Sprintf("%04d", seriesNumber)
	filename := fmt.Sprintf("%s.json", stub)
	return path.Join(outputDir, filename)
}

// isLabradarCsvFile will perform some basic checking to see if a given filename could be that of a Labadar CSV file.
func isLabradarCsvFile(path string) bool {
	b := strings.ToLower(filepath.Base(path))
	ext := filepath.Ext(b)
	if ext == ".csv" {
		sr := b[0:2]
		if sr == "sr" {
			return true
		}
	}

	return false
}

// getCsvFilenamesInDirectory will return a list of Labradar CSV files in a given directory
func getCsvFilenamesInDirectory(inputDir string) []string {

	var filenames []string

	// TODO [TO20211122] Can't really mock out filepath.Walk.
	err := filepath.Walk(inputDir, func(path string, info os.FileInfo, err error) error {
		if !info.IsDir() && isLabradarCsvFile(path) {
			filenames = append(filenames, path)
		}
		return nil
	})
	if err != nil {
		logrus.Errorf("Could not list files in the directory %s. %v", inputDir, err)
		return nil
	}

	return filenames
}

func closeFile(f afero.File) {
	err := f.Close()
	if err != nil {
		fmt.Println(err)
	}
}
