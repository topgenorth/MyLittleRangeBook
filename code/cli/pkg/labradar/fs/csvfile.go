package fs

import (
	"bufio"
	"fmt"
	"github.com/carolynvs/aferox"
	"opgenorth.net/mylittlerangebook/pkg/labradar/series"
	"strconv"
	"strings"
	"time"
)

// CsvFile is a serialized Labradar CSV file.
type CsvFile struct {
	InputFile string
	Error     error
	lines     []string
}

func (f CsvFile) String() string {
	return f.InputFile
}

// LbrFiles is a collection of all the serialized CSV files that are generated by LabRadar.
type LbrFiles struct {
	InputDir string
	Files    []*CsvFile
}

func (df LbrFiles) String() string {
	return df.InputDir
}

// loadCsv will read a file line at a time, capturing each line of test for future processing.
func loadCsv(filename string, fs aferox.Aferox) *CsvFile {
	csv := &CsvFile{
		InputFile: filename,
		Error:     nil,
		lines:     nil,
	}

	f, err := fs.Open(filename)
	if err != nil {
		csv.Error = fmt.Errorf("could not load the series at %s: %w", filename, err)
		return csv
	}
	defer CloseFile(f)

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		csv.lines = append(csv.lines, line)
	}

	return csv
}

// GetMutatorsToUpdateSeries will return an array of mutators to up date a LabradarSeries with the contents of a
// CSV file.
func GetMutatorsToUpdateSeries(seriesNumber int, directory string, af aferox.Aferox) ([]series.LabradarSeriesMutatorFunc, error) {
	filename := FilenameForSeries(directory, seriesNumber)
	exists, err := af.Exists(filename)
	if err != nil {
		return make([]series.LabradarSeriesMutatorFunc, 0), fmt.Errorf("could not load the file '%s': %w", filename, err)
	}
	if !exists {
		return make([]series.LabradarSeriesMutatorFunc, 0), fmt.Errorf("could not load the file '%s'", filename)
	}

	// [TO20220118] We dereference file - the thought being that this could allow us to parallelize this? Probably
	// a case of premature optimization though.
	file := *loadCsv(filename, af)
	return []series.LabradarSeriesMutatorFunc{
		withDeviceIdFrom(file),
		withSeriesNumberFrom(file),
		withUnitsOfMeasureFrom(file),
		addMuzzleVelocitiesFrom(file),
		withSeriesDateFrom(file),
	}, nil

}

func withSeriesDateFrom(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		d, t := getDateAndTime(file, 18)
		s.Date = d
		s.Time = t
	}
}

func withDeviceIdFrom(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.DeviceId = getStringValue(file, 1)
	}
}
func withSeriesNumberFrom(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.Number = getIntValue(file, 3)
	}
}
func withUnitsOfMeasureFrom(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.UnitsOfMeasure.Velocity = getStringValue(file, 6)
		s.UnitsOfMeasure.Distance = getStringValue(file, 7)
		s.UnitsOfMeasure.Weight = getStringValue(file, 9)
	}
}
func addMuzzleVelocitiesFrom(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		for i := 18; i < len(file.lines); i++ {
			velocity := getIntValue(file, i)
			s.Velocities.Values = append(s.Velocities.Values, velocity)
		}
	}
}

func getDateAndTime(file CsvFile, lineNumber int) (string, string) {
	l := file.lines[lineNumber]
	parts := strings.Split(l, ";")
	x := len(parts)
	if x == 1 {
		return "", ""
	}

	d := parts[x-3]
	t := parts[x-2]
	mydate, _ := time.Parse("01-02-2006 15:04:05", d+" "+t)

	return mydate.Format("2006-Jan-02"), mydate.Format("15:04")

}
func getIntValue(file CsvFile, lineNumber int) int {
	l := file.lines[lineNumber]
	parts := strings.Split(l, ";")
	i, err := strconv.Atoi(parts[1])
	if err != nil {
		return -1
	}
	return i
}
func getStringValue(file CsvFile, lineNumber int) string {
	line := file.lines[lineNumber]
	parts := strings.Split(line, ";")
	return parts[1]
}
