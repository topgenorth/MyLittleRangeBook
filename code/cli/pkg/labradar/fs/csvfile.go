package fs

import (
	"bufio"
	"fmt"
	"github.com/carolynvs/aferox"
	"opgenorth.net/mylittlerangebook/pkg/labradar/series"
	"strconv"
	"strings"
	"time"
)

// CsvFile is a serialized Labradar CSV file.
type CsvFile struct {
	InputFile string
	Error     error
	lines     []string
}

func (f CsvFile) String() string {
	return f.InputFile
}

// LbrFiles is a collection of all the serialized CSV files that are generated by LabRadar.
type LbrFiles struct {
	InputDir string
	Files    []*CsvFile
}

func (df LbrFiles) String() string {
	return df.InputDir
}

// LoadCsv will read a file line at a time, capturing each line of test for future processing.
func LoadCsv(filename string, fs aferox.Aferox) *CsvFile {
	csv := &CsvFile{
		InputFile: filename,
		Error:     nil,
		lines:     nil,
	}

	f, err := fs.Open(filename)
	if err != nil {
		csv.Error = fmt.Errorf("could not load the series at %s: %w", filename, err)
		return csv
	}
	defer CloseFile(f)

	scanner := bufio.NewScanner(f)
	for scanner.Scan() {
		line := scanner.Text()
		csv.lines = append(csv.lines, line)
	}

	return csv
}

func FromCsvFile(filename string, fs aferox.Aferox) ([]series.LabradarSeriesMutatorFunc, error) {
	exists, err := fs.Exists(filename)
	if err != nil {
		return make([]series.LabradarSeriesMutatorFunc, 0), fmt.Errorf("could not load the file '%s': %w", filename, err)
	}
	if !exists {
		return make([]series.LabradarSeriesMutatorFunc, 0), fmt.Errorf("could not load the file '%s'", filename)
	}

	file := *LoadCsv(filename, fs)
	return []series.LabradarSeriesMutatorFunc{
		withDeviceId(file),
		withSeriesNumber(file),
		withUnitsOfMeasure(file),
		addMuzzleVelocities(file),
		//withSeriesDate(file),
	}, nil

}

//func withSeriesDate(file CsvFile) series.LabradarSeriesMutatorFunc {
//	return func(s *series.LabradarSeries) {
//		d, t := getDateAndTime(file, 18)
//		s.Labradar.Time = t
//		s.Labradar.Date = d
//	}
//}
func withDeviceId(csv CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.DeviceId = getStringValue(csv, 1)
	}
}
func withSeriesNumber(csv CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.Number = getIntValue(csv, 3)
	}
}
func withUnitsOfMeasure(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		s.UnitsOfMeasure.Velocity = getStringValue(file, 6)
		s.UnitsOfMeasure.Distance = getStringValue(file, 7)
		s.UnitsOfMeasure.Weight = getStringValue(file, 9)
	}
}
func addMuzzleVelocities(file CsvFile) series.LabradarSeriesMutatorFunc {
	return func(s *series.LabradarSeries) {
		for i := 18; i < len(file.lines); i++ {
			velocity := getIntValue(file, i)
			s.Velocities.Values = append(s.Velocities.Values, velocity)
		}
	}
}

func getDateAndTime(file CsvFile, lineNumber int) (string, string) {
	l := file.lines[lineNumber]
	parts := strings.Split(l, ";")
	x := len(parts)
	if x == 1 {
		return "", ""
	}

	d := parts[x-3]
	t := parts[x-2]
	mydate, _ := time.Parse("01-02-2006 15:04:05", d+" "+t)

	return mydate.Format("2006-Jan-02"), mydate.Format("15:04")

}
func getIntValue(file CsvFile, lineNumber int) int {
	l := file.lines[lineNumber]
	parts := strings.Split(l, ";")
	i, err := strconv.Atoi(parts[1])
	if err != nil {
		return -1
	}
	return i
}
func getStringValue(file CsvFile, lineNumber int) string {
	line := file.lines[lineNumber]
	parts := strings.Split(line, ";")
	return parts[1]
}
